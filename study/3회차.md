## 인성 질문

### 1. 자신의 장단점에 대해 말씀해주세요.

저의 장점은 집요함입니다.
예를 들어, 인턴십 프로젝트에서 라이브러리가 지원하지 않는 기능을 구현해야 했습니다.
이를 해결하기 위해 1주일간 철저히 자료를 조사한 끝에, 오픈소스 예제를 확장하여 요구 사항을 성공적으로 달성한 경험이 있습니다.
이처럼 주어진 요구 사항을 달성하는 과정에서 어려움이 생기면, 문제를 깊이 분석하고 반드시 해결책을 찾아냅니다.

저의 단점은 지나친 꼼꼼함과 완벽주의 성향입니다.
작은 부분에 너무 집중하는 경향이 있어, 불필요하게 시간이 오래 걸리거나 작은 프로젝트에 필요치 않은 과도한 세팅을 할 때도 있습니다.

이를 극복하기 위해 개인 프로젝트에서 제가 해보고 싶었던 것들을 자유롭게 시도하며, 우선순위를 설정하고 적절한 타협점을 찾는 방법을 익혀가고 있습니다.

---

## 기술 질문

### 1. 이벤트 루프에 대해 설명해주세요.

이벤트 루프는 자바스크립트가 싱글 스레드임에도 불구하고 실행 환경에서 동시성을 지원할 수 있게 해주는 요소 중 하나입니다.
이벤트 루프는 콜 스택이 비어 있는지 지속적으로 확인하고, 비어 있다면 태스크 큐에 대기 중인 작업을 콜 스택으로 옮기는 역할을 합니다.

예를 들어 setTimeout을 사용한 예시를 들어보겠습니다.
코드에서 setTimeout 블록이 실행되면, 해당 콜백 함수는 즉시 실행되지 않고 태스크 큐로 이동합니다.
이 시점에서 setTimeout 함수 자체는 콜 스택에서 제거됩니다.
이후 이벤트 루프는 콜 스택이 비어 있는지 확인하고, 비어 있으면 대기 중인 태스크 큐의 콜백을 콜 스택으로 이동시킵니다.
그 후 콜 스택에서 해당 콜백 함수가 실행됩니다.

### 2. Next.js의 렌더링 방식 4가지에 대해 설명해주세요.

Next.js는 서버에서 미리 렌더링을 수행한 후 HTML 파일을 클라이언트에게 전달합니다.

페이지가 렌더링된 후에 클라이언트에서 데이터를 fetch하는 방식은 CSR 방식입니다.
정적인 부분만 처음 HTML에 포함되고, 이후 동적인 데이터는 클라이언트 측에서 비동기 작업을 수행해 화면에 표시됩니다.

만약 페이지 로드 시 데이터가 포함된 HTML을 받고 싶을 때는 SSG, ISR, SSR 방식을 사용할 수 있습니다.

SSG는 빌드 타임에 정적 HTML 페이지를 미리 생성하여, 서버가 아닌 CDN에서 제공하는 방식입니다.
매우 빠른 로딩 속도를 가지고 있으며, 데이터가 자주 변경되지 않는 페이지에 적합합니다.

ISR은 SSG의 이점을 유지하면서도, 일정 주기마다 페이지를 다시 생성하여 최신 데이터를 반영할 수 있는 방식입니다.
getStaticProps에 revalidate 옵션을 통해 데이터를 갱신할 수 있습니다.

SSR은 페이지 요청을 할 때 마다 서버에서 데이터를 fetch하여 HTML을 동적으로 생성하는 방식입니다.
이 방식은 항상 최신 데이터를 보장하지만, 요청마다 서버에서 페이지를 생성하므로 SSG나 ISR보다 느릴 수 있습니다.

### 3. 푸시 알림을 통한 재참여를 제외하고 PWA를 도입하신 다른 이유가 또 있을까요?

네, PWA의 핵심 요소 중 하나인 앱 아이콘을 통한 접근성 향상을 위해 manifest.json을 작성하였습니다.
이를 통해 데스크톱과 모바일에서 앱 아이콘을 사용한 빠른 접근이 가능해졌습니다.
특히 여행 예약 앱의 경우, 디바이스에 관계없이 예약 현황의 지속적인 업데이트가 중요하다고 판단하여, 앱 아이콘을 통한 접근성을 높였습니다.

또한, 오프라인 폴백 페이지를 도입하여, 모바일 환경에서 네트워크 상태가 좋지 않을 때 기본적으로 표시되는 페이지를 제공하였습니다.
이를 통해 사용자는 인터넷 연결 상태를 확인하고 재시도할 수 있게끔 유도할 수 있었습니다.

종합적으로 모바일에서도 네이티브 앱과 같은 사용자 경험을 제공하기 위해 PWA를 도입하였습니다.

### 4. Recoil 라이브러리를 사용한 이유와 적용된 예시가 궁금합니다.

해당 프로젝트에서는 다양한 이벤트가 존재했습니다.
사용자는 작도를 그리거나, 건축물을 지도 위에 올리거나, 건물의 각 층을 탐방하는 작업을 했고, 이 모든 이벤트가 하나의 마우스 클릭에 의존했습니다.
서로 다른 이벤트가 겹치지 않도록 하기 위해 atom 단위로 현재 어떤 이벤트가 진행 중인지 전역 상태에서 관리할 필요가 있었고, 이를 위해 Recoil을 사용하게 되었습니다.

Recoil을 선택한 이유는 Facebook에서 개발한 라이브러리라는 신뢰성과, 러닝 커브가 낮다는 장점 때문이었습니다.
그러나 Recoil이 더 이상 활발히 업데이트되지 않는 점과, 이후에 Jotai를 사용해본 결과, Jotai가 Recoil보다 더 나은 대안이라고 느꼈습니다.
같은 상황이 다시 온다면, Jotai를 사용할 것 같습니다.
