## 인성 질문

### 1. 같이 일하고 싶거나 일하고 싶지 않은 동료는?

제가 같이 일하고 싶은 동료는 변화에 유연하고, 소통에 적극적인 개발자입니다.
또한, 프론트엔드 업무가 프로젝트의 마지막 단계에서 진행되는 경우가 많기 때문에, 시간 엄수를 잘하는 개발자와 함께 일하고 싶습니다.
그리고 개발 자체에 흥미를 가지고, 열정을 가진 동료나 사수와 함께 일하며 많이 배우고 성장하고 싶습니다.

반면, 팀 프로젝트에서는 개발 실력보다 원활한 소통이 더욱 중요하다고 생각하기 때문에,
진행 상황을 공유하지 않거나 커뮤니케이션을 하지 않는 사람과는 함께 일하고 싶지 않습니다.
또한, 다른 사람의 제안을 받아들이지 않고, 다른 관점으로 보지 못하는 사람과도 일하기 어렵다고 생각합니다.

---

## 기술 질문

### 1. 동기, 비동기에 대해 설명하세요

동기는 모든 작업이 순차적으로 진행되는 방식을 의미합니다. 코드가 실행될 때 이전 줄의 코드가 완료되어야만 다음 줄의 코드가 실행됩니다. 동기 방식으로 작성된 코드는 이해하기 쉽고 예측 가능하지만, 각 작업의 완료를 기다리는 동안 시간 지연이 발생할 수 있는 단점이 있습니다.

반면, 비동기는 이전 작업의 완료 여부를 기다리지 않고 다른 작업을 동시에 진행할 수 있는 방식입니다. 즉, 이전 줄의 코드 실행이 완료되지 않아도 다음 코드를 실행할 수 있습니다.

JS는 싱글 스레드 언어로, 독립적으로 비동기 작업을 처리할 수 없습니다. 대신, JS는 실행 환경과 함께 비동기 작업을 처리합니다.
예를 들어, 브라우저 환경에서 Web API인 fetch가 실행되면, 해당 코드는 콜 스택에서 바로 pop되고, 브라우저라는 멀티 스레드 소프트웨어가 동시에 작업을 진행합니다.
작업이 완료되면, 후속 처리 메서드의 콜백 함수가 태스크 큐에 대기하게 됩니다.

콜 스택에서는 다음 작업이 계속해서 수행되며, 이벤트 루프가 콜 스택이 비어 있는지 확인한 후, 태스크 큐에 대기 중인 콜백 함수를 콜 스택으로 옮겨 실행하는 방식으로 비동기 작업이 이루어집니다.

#### 꼬리 질문

1. 스레드란?
   스레드란 프로그램 내에서 실행되는 하나의 작업 흐름 단위입니다.

### 2. React에서 Virtual DOM을 사용하는 이유를 설명하세요.

먼저 가상 DOM의 탄생 배경에 대해 먼저 말씀드리겠습니다.
리액트와 같은 SPA에서는 모든 작업이 하나의 페이지 내에서 이루어지기 때문에, 추가 렌더링 작업이 자주 발생합니다.
페이지 이동 또한 실제 주소를 가지고 HTML을 다운받는 것이 아닌 새롭게 리렌더링하는 방식으로 처리됩니다.
이처럼 DOM 조작이 이렇게 반복되면 성능에 무리가 갈 수 있습니다.

이를 해결하기 위해 매번 실제 DOM을 변경하는 대신 리렌더링 시 최종적으로 만들어질 DOM 결과물만 알고자 했습니다. 이 배경에서 가상 DOM이 도입되었습니다.

React에서는 단순한 JavaScript 객체로 구성된 렌더링 이전의 가상 DOM과 렌더링 이후의 가상 DOM 두 개를 관리합니다.
리렌더링이 발생하면 새롭게 업데이트된 가상 DOM이 생성되고, 이 가상 DOM과 이전의 가상 DOM을 비교하여 변경된 요소를 찾아냅니다.
그런 다음, 변경된 부분만 실제 DOM에 한 번에 적용하여 렌더링 이후의 가상 DOM과 실제 DOM을 일치시킵니다.

이러한 가상 DOM을 도입함으로써 다양한 업데이트가 발생하는 웹 앱에서는 동시에 발생한 업데이트를 모으고 한 번에 수정하여 리플로우와 리페인트 횟수를 최소하하는 장점이 있습니다.

#### 꼬리 질문

1. 가상 DOM을 사용하는 리액트의 방식이 일반적인 DOM을 관리하는 브라우저보다 항상 빠른가요?
   가상 DOM을 사용하는 방식은 가상 DOM끼리 비교하고 한 번에 변경하는 과정으로 진행됩니다.
   가상 DOM을 생성하고 비교하는데에도 연산이 소요되기 때문에 변경 사항이 적은 경우에는 직접 DOM 조작이 가상 DOM을 사용하는 방식보다 빠를 수 있다.
   가상 DOM 방식은 복잡합 UI나, 사용자 상호작용으로 빈번한 업데이트가 발생할 때 효율적이다.

2. 리렌더링 조건

- setState가 실행
- props 변경
- 부모 컴포넌트가 리렌더링 된 경우, 자식 컴포넌트 리렌더링
- context 값이 변경되었을 때 해당 context를 구독하고 있는 모든 컴포넌트 리렌더링

### 3. TanStack Query가 어떻게 캐싱되는지 설명하세요.

TanStack Query는 Query Key와 staleTime을 기준으로 데이터를 캐싱하고, 이를 효율적으로 관리합니다.

useQuery를 예시로 설명하자면, useQuery가 실행될 때 해당 Query Key에 해당하는 데이터가 캐시에 없다면, 쿼리 함수를 실행하여 받은 데이터를 캐시에 저장합니다.

만약 쿼리 키에 해당하는 데이터가 캐시에 있다면, 이때는 데이터의 상태에 따라 다르게 동작합니다.
데이터의 상태가 fresh인 경우 단순히 캐시에 저장되어 있는 데이터를 리턴하고,
데이터의 상태가 stale인 경우 다시 fetch하고 새로운 데이터로 캐시에 저장되어 있는 데이터를 갱신합니다.

내부 동작에 대해 제가 아는만큼만 말씀드리면 캐시된 데이터는 실행 환경의 메모리에 저장되며, 이때 Map 객체를 사용하여 데이터를 관리하는 것으로 알고 있습니다.

#### 꼬리 질문

1. staleTime과 cacheTime의 차이

staleTime은 캐시된 데이터를 사용할 수 있는 유효한 시간을 의미하는 반면,
cacheTimedms GC에 의해 데이터가 매모리 내의 캐시에서 제거되기까지의 시간을 의미합니다.

2. 백그라운드 갱신 조건

- 윈도우에 다시 포커스 될 때
- 네트워크 재연결
- 자동 갱신 옵션 (refetchInterval)
- 사용자가 다시 쿼리를 호출할 때
