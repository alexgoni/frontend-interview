## 자바스크립트에서 == 와 === 가 어떻게 다른지 설명해 주세요.

`==`은 값이 같은지 비교합니다.  
이때 두 값을 공통 형으로 암묵적으로 변환합니다.

반면 `===`은 값뿐만아니라 타입도 비교합니다.

## 자바스크립트에서 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)에 대해 설명해 주세요.

얕은 복사는 주소 값을 복사하는 것입니다.  
깊은 복사는 복사하려는 객체와 똑같은 값을 가진 객체를 메모리 공간에 새로 만들어서 해당 주소 값을 할당하는 것입니다.

## var, let, const 를 중복 선언 허용, 스코프, 호이스팅 관점에서 서로 비교해 주세요.

var는 같은 변수를 중복 선언이 가능한 반면, let과 const는 허용되지 않습니다.

var는 함수 레벨 스코프를 가지는 반면, let과 const는 블록 레벨 스코프를 가집니다.

호이스팅이란 JS 인터프리터가 코드를 실행하기 전, 전체를 스캔하면서 모든 선언문을 확인하며 일종의 변수 사전을 만듦으로서 생기는 현상입니다.

var로 선언된 변수의 경우 undefined로 처음 초기값이 할당되어,
선언 부분 위에서도 참조할 수 있습니다.

이처럼 함수 선언문이 코드 상위로 올라간 것처럼 보이는 현상을 호이스팅이라고 하는데 이는 만들어진 것이 아닌 JS 엔진에 의한 자연스러운 현상입니다.

반면 ES6 이후로 나온 let과 const는 변수 사전에 등록은 되더라도 초기값은 할당하지 않습니다.
때문에 선언 부분 위에서 해당 변수를 참조하려고 하면 Reference Error가 발생합니다.
이 구간을 일시적 사각지대 TDZ라고 합니다.

## 브라우저가 어떻게 동작하는지 설명해 주세요.

주소창에 google.com을 입력하면 브라우저는 먼저 DNS 서버에 요청을 보내고, 그에 대한 IP 주소를 수신합니다. 브라우저는 받은 IP 주소를 통해 웹 서버에게 GET 요청을 전송합니다. 요청을 받은 웹 서버는 이에 해당하는 HTML, CSS, JavaScript 파일과 웹 페이지를 구성하는 여러 리소스를 응답합니다.

브라우저는 응답받은 리소스를 이용해 웹 페이지 렌더링 과정을 거칩니다.
저는 이 렌더링 과정에 대해 집중적으로 말씀드리겠습니다.

브라우저의 렌더링 엔진은 HTML과 CSS를 파싱하여 DOM과 CSSOM을 생성합니다.
이 두 가지를 결합하여 렌더 트리를 생성한 후, 각 요소의 위치를 계산하는 레이아웃 과정과 화면을 그리는 페인팅 과정이 이어집니다.

HTML을 한 줄씩 해석하다 async가 defer 어트리뷰트가 없는 script 태그를 만나게 되면 DOM 생성을 중단되고, JS의 파싱과 실행이 시작됩니다.
이때 제어권은 브라우저의 렌더링 엔진에서 JS 엔진으로 넘어갑니다

JavaScript 엔진은 DOM과 CSSOM을 생성하는 것처럼 추상 구문 트리를 생성합니다.
이후 AST를 기반으로 인터프리터가 실행할 수 있는 바이트 코드를 생성하고, 이를 실행합니다.

최종적으로 이를 통해서 사용자는 완성된 웹 페이지를 보게됩니다.

## 이벤트 버블링, 캡쳐링, 위임에 대해 설명해 주세요.

이벤트의 전파는 최상위 window 객체에서부터 타깃 요소까지 내려갔다가 다시 최상위 window 객체로 올라오는 방식으로 이루어집니다.

첫 번째 캡처링 단계는 이벤트가 상위에서 하위로 내려가는 순으로 발생합니다.  
이 단계에서 이벤트를 처리하려면 addEventListener에 capture 옵션을 true로 설정하면 됩니다.

두 번째 버블링 단계는 이벤트가 하위에서 상위로 전파되는 과정을 의미합니다.  
예를 들어, 하위 요소에서 click 이벤트가 발생했을 때, 상위 부모 요소에 click 이벤트 리스너가 설정되어 있다면 그에 해당하는 콜백 함수가 실행됩니다.

이를 활용한 것이 이벤트 위임입니다.
하위 요소들 각각에 이벤트 리스너를 붙이는 대신, 공통된 상위 요소에 하나의 이벤트 리스너를 붙여 하위 요소의 이벤트를 제어하는 방식입니다.  
이 방법을 통해 코드의 효율성을 높이고 성능 최적화를 이룰 수 있습니다.

## 자바스크립트 this에 대해 설명해 주세요.

this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수입니다.  
이때 this가 가리키는 값은 함수 호출 방식에 의해 동적으로 결정됩니다.

일반 함수에서의 this는 전역 객체를 의미합니다.  
메서드에서의 this는 메서드를 호출한 객체를 의미합니다.  
생성자 함수에서의 this는 생성자 함수가 생성할 인스턴스를 의미합니다.

## 렉시컬 스코프(Lexical scope)에 대해 설명해 주세요.

스코프란 식별자의 유효 범위를 뜻합니다.

렉시컬 스코프는 식별자의 유효 범위가 함수를 호출할 때 결정되는 것이 아닌 선언할 때 결정되는 것을 뜻합니다.  
JS는 렉시컬 스코프를 따릅니다.

## HTTP 메소드에 대해 설명해 주세요.

### GET

| 데이터를 받기 위해 사용하는 메소드

- 리퀘스트 바디 사용 x, 쿼리 스트링 사용
- 서버의 데이터 변경이 일어나지 않음

### POST

| 새로운 리소스를 생성하기 위해 서버에 데이터를 보내는 메소드

- 리퀘스트 바디 사용

### PUT

| 기존 리소스를 수정하기 위해 서버에 데이터를 보내는 메소드

- 서버에 리소스가 없으면 생성하고, 있으면 교체

### PATCH

| 기존 리소스의 부분적인 수정을 위한 메소드

### DELETE

| 지정한 리소스를 삭제하는 메소드

- 리퀘스트 바디 사용 x

### HEAD

| 특정 리소스를 GET 메소드로 요청했을 때 돌아올 헤더를 받기 위한 메소드

## 이벤트 루프에 대해 설명해주세요.

이벤트 루프는 자바스크립트가 싱글 스레드임에도 불구하고 실행 환경에서 동시성을 지원할 수 있게 해주는 요소 중 하나입니다.  
이벤트 루프는 콜 스택이 비어 있는지 지속적으로 확인하고, 비어 있다면 태스크 큐에 대기 중인 작업을 콜 스택으로 옮기는 역할을 합니다.

예를 들어 setTimeout을 사용한 예시를 들어보겠습니다.  
코드에서 setTimeout 블록이 실행되면, 해당 콜백 함수는 즉시 실행되지 않고 태스크 큐로 이동합니다.  
이 시점에서 setTimeout 함수 자체는 콜 스택에서 제거됩니다.  
이후 이벤트 루프는 콜 스택이 비어 있는지 확인하고, 비어 있으면 대기 중인 태스크 큐의 콜백을 콜 스택으로 이동시킵니다.  
그 후 콜 스택에서 해당 콜백 함수가 실행됩니다.

## 프로토타입 체인에 대해 설명해 주세요.

프로토타입 체인은 JS에서 객체 지향 프로그래밍을 구현하는 데 사용되는 상속 메커니즘입니다.  
객체가 다른 객체의 속성이나 메서드를 참조할 수 있도록 연결하는 방식입니다.

객체에서 특정 프로퍼티나 메서드를 호출하면 객체 자체에 해당 프로퍼티가 있는지 확인하고, 없다면 `[[Prototype]]` 내부 슬롯을 통해 부모 객체에서 검색을 계속합니다.

## AJAX에 대해 설명해 주세요.

Ajax란 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식입니다.

Ajax를 통해서 현재 페이지를 유지한 채로 새로운 페이지를 로드하지 않고도 페이지에 변화를 줄 수 있습니다.

## 자바스크립트 실행 컨텍스트(Execution context)에 대해 설명해 주세요.

실행 컨텍스트는 코드를 실행하는 데 필요한 환경을 제공하는 객체입니다.  
코드가 실행되기 위해서는 식별자, 스코프, 코드의 실행 순서 등을 관리해야 하며, 이러한 요소들을 실행 컨텍스트가 관리합니다.

식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리됩니다.  
렉시컬 환경은 환경 레코드와 외부 렉시컬 환경에 대한 참조로 구성됩니다.  
환경 레코드는 스코프에 포함된 식별자를 등록하고, 바인딩 된 값을 관리하는 저장소입니다.  
외부 렉시컬 환경에 대한 참조는 상위 스코프의 렉시컬 환경을 참조하여 스코프 체인을 형성합니다.

그리고 코드의 실행 순서는 실행 컨텍스트 스택으로 관리됩니다.  
실행 컨택스트 스택은 후입선출 방식의 자료구조이며, 콜스택이라고 부르기도 합니다.  
함수가 호출되면 실행 컨텍스트가 스택에 추가되고, 실행이 완료되면 제거됩니다.

## 클로저가 무엇인지 그리고 JavaScript에서 어떤 경우에 활용하면 좋을지 예시와 함께 설명해 주세요.

클로저는 자신이 선언될 당시의 환경을 기억하는 함수로,
주로 중첩된 함수로 구현됩니다.

외부 함수의 실행이 종료되고 콜 스택에서 제거된 후에도 내부 함수가 외부 함수의 변수를 계속해서 참조하는 경우를 의미합니다.

이를 활용하면 함수 외부에서 접근할 수 없는 변수를 만들어 정보 은닉을 구현하거나,
메서드를 통해서만 상태를 관리하는 방식으로 사용할 수 있습니다.
