# JavaScript

## 프로그래밍

### 프로그래밍이란 뭐라고 생각하나요?

프로그래밍이란 문제 해결을 위한 도구라고 생각합니다.
0과 1, 단 두 가지 상태로 시작하여 불가능하다고 여겼던 것들을 현실로 만들어내는 과정입니다.

### 컴파일러는 뭐고 인터프리터는 뭔가요?

컴파일러는 프로그램 전체를 스캔하여 한 번에 모두 기계어로 번역한 후, 실행 파일을 생성합니다.
이 과정에서 실행 전에 오류를 발견할 수 있습니다.

반면, 인터프리터는 프로그램 실행 시 한 문장씩 번역하여 즉시 실행합니다.
따라서 런타임 도중에 오류를 발견하는 차이가 있습니다.

## 자바스크립트

### 자바스크립트의 특징은 뭐가 있나요?

자바스크립트는 웹을 구성하는 요소 중 하나로, 웹 브라우저에서 동작하는 유일한 프로그래밍 언어입니다. 초기에는 동적인 웹페이지를 만들기 위한 단순한 스크립트 언어였지만, V8 엔진의 등장으로 Node.js 환경에서도 동작할 수 있게 되었습니다.

자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어로, 이를 통해 빠르게 실행될 수 있는 특징이 있습니다.

또한, 싱글 스레드 기반 언어로서 한 번에 하나의 태스크만 처리할 수 있으며, 동적 타입 언어로서 변수의 타입을 미리 지정하지 않아 데이터 타입이 동적으로 변할 수 있는 특징을 가지고 있습니다.

## 변수

### 변수란 무엇인가요?

변수는 데이터를 저장하기 위해 확보한 메모리 공간을 식별하기 위해 붙인 이름을 말합니다.

### 식별자는 무엇인가요?

식별자는 JS에서 이름을 붙일 때 사용하는 단어입니다.
메모리 상에 존재하는 어떤 갓ㅂ을 식별할 수 있는 이름은 모두 식별자라고 부릅니다.
식별자의 종류로는 변수명, 함수명, 메서드명 등이 있습니다.

### 변수를 선언한다는 것은 어떤 것을 의미하나요?

변수 선언은 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것입니다.
JS에서는 변수 선언을 위해 var, let, const 키워드를 사용합니다.

### var 키워드는 뭔가요? & 문제점은 무엇이 있나요?

var 키워드는 ES6 이전에 변수 선언에 사용되던 키워드입니다.

var 키워드로 선언된 변수는 다음과 같은 특징이 있습니다.

1. 변수 중복 선언 허용

```js
var x = 1;
var x = 2;

console.log(x); // 2
```

2. 함수 레벨 스코프

```js
var x = 1;

if (true) {
  var x = 10;
}

console.log(x); // 10
```

3. 변수 호이스팅

```js
console.log(score); // undefined

var score;
```

이러한 특징 때문에 코드를 유지 보수하기 어렵게 만드는 원인이 되므로 사용을 지양합니다.

### 호이스팅이 뭔가요?

호이스팅이란 인터프리터가 변수나 함수의 선언을 실행 전에 미리 메모리에 할당하는 현상을 의미합니다. 자바스크립트 엔진은 런타임 이전에 코드의 선언 부분을 모두 스캔해 변수와 함수에 대한 정보를 미리 준비해 두고, 코드가 실행될 때 이를 참조할 수 있게 합니다.

변수나 함수가 코드 상에서 위로 끌어올려진 것처럼 보이지만, 호이스팅은 만들어진 기능이 아닌 JS 엔진에 의한 자연스러운 현상입니다.

### let 키워드는 var 키워드와 어떤 점이 다른가요?

let 키워드는 var 키워드의 단점을 보완하기 위해 ES6에서 도입된 새로운 키워드입니다.

1. 변수 중복 선언 금지
2. 블록 레벨 스코프
   코드 블록 내에 선언된 변수는 스코프를 사용할 수 없습니다.
3. 변수 호이스팅
   let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작합니다.
   let 키워드로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행됩니다.
   따라서 초기화 단계가 실행되기 이전에 let으로 선언된 변수에 접근하려고 하면 참조 에러가 발생합니다.
4. 전역 객체와 let
   var와 달리 let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아닙니다.

### const 키워드는 어떤 특징이 있나요?

1. 선언과 초기화
   const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 합니다.
2. 재할당 금지
3. 상수
   const 키워드로 선언한 변수에 원시 값을 할당한 경우 변수 값을 변경할 수 없습니다.

### TDZ

변수의 lifecycle은 세 단계로 이루어집니다.

1. 선언 단계: 소스코드 평가 과정에서 변수는 실행 컨텍스트에 등록됩니다.
2. 초기화 단계: 변수에 메모리가 할당됩니다.
3. 할당 단계: 변수에 실제 값이 할당됩니다.

var의 경우 선언 단계와 초기화 단계가 소스코드 평가 과정 이전에 한번에 이루어지지만,
const, let의 경우 선언 단계와 초기화 단계가 분리되어 진행됩니다.
따라서 초기화 단계가 실행되기 이전에 const, let으로 선언된 변수에 접근하려고 하면 참조 에러가 발생합니다.

이때 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 일시적 사각지대 TDZ라고 합니다.

### 식별자 네이밍 규칙은 어떤 것들이 있나요?

식별자는 특수문자를 제외한 문자, 숫자, 언더스코어, 달러 기호를 포함할 수 있습니다.
단 숫자로 시작하는 것은 허용하지 않습니다.

### 네이밍 컨벤션은 어떤 것들이 있나요?

1. 카멜 케이스

```js
let firstName;
```

2. 스네이크 케이스

```js
let first_name;
```

3. 파스칼 케이스

```js
let FirstName;
```

### 리터럴이 뭔가요?

리터럴이란 값을 생성하기 위해 미리 약속한 표기법입니다.
숫자 리터럴 3을 코드에 기술하면 JS 엔진은 이를 평가해 숫자 값 3을 생성합니다.
즉, JS 엔진은 런타임에 리터럴을 평가해 값을 생성합니다.

## 데이터 타입

### 데이터 타입의 종류는 어떤 것들이 있나요?

원시 타입으로 숫자, 문자열, 불리언, undefined, null, 심벌, BigInt 총 7가지가 있고,
객체 타입으로 하나 있습니다.

### 심벌 타입은 뭐죠?

심벌 값은 다른 값과 중복되지 않는 유일무이한 값입니다.
주로 객체의 유일한 프로퍼티 키를 만들기 위해 사용합니다.
중복될 가능성이 없는 심벌 값으로 프로퍼티 키를 생성하여 기존의 객체를 안전하게 확장할 수 있습니다.

### 데이터 타입은 왜 필요할까요?

1. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
2. 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
3. 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

### 정적 타이핑이 뭔가요?

정적 타이핑은 C나 Java 같은 정적 타입 언어에서 사용되는 개념으로, 변수를 선언할 때 그 변수의 데이터 타입을 미리 지정해야 하는 방식을 말합니다.
정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있습니다.
컴파일 시점에 타입 체크를 수행하고, 통과하지 못했다면 프로그램의 실행 자체를 막습니다.

### 동적 타이핑이 뭔가요?

JS는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않습니다.
JS의 변수는 선언이 아닌 할당에 의해 타입이 추론되고, 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있습니다. 이러한 특징을 동적 타이핑이라고 합니다.

## 타입변환과 단축 평가

### 명시적 타입 변환이 뭔가요?

개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라고 합니다.

### 명시적 타입 변환 함수를 예를 들어볼 수 있나요?

명시적 타입 변환을 하는 방법으로 세 가지가 있습니다.

1. 표준 빌트인 생성자 함수를 new 연산자 없이 호출
2. 빌트인 메서드 사용
3. 암묵적 타입 변환 이용

#### 문자열 타입으로 변환

1. String 생성자 함수

```js
String(123);
```

2. Object.prototype.toString 메서드

```js
(1).toString();
```

3. 암묵적 타입 변환

```js
1 + "";
```

#### 숫자 타입으로 변환

1. Number 생성자 함수

```js
Number("0");
```

2. parseInt, parseFloat 메서드

```js
parseInt("0");
```

3. 암묵적 타입 변환

```js
+"1";
"1" * 1;
```

#### 불리언 타입으로 변환

1. Boolean 생성자 함수

```js
Boolean("x");
```

2. ! 부정 논리 연산자를 두 번 사용

```js
!!"x";
```

### 암묵적 타입 변환이 뭔가요?

JS 엔진이 표현식을 평가하는 도중에 JS 엔진에 의해 암묵적으로 타입이 자동 변환되기도 합니다. 이를 암묵적 타입 변환이라고 합니다.

### truthy / falsy 한 값이 뭔가요?

참으로 평가되는 값을 Truthy 값, 거짓으로 평가되는 값을 Falsy 값이라고 합니다.
조건식과 같이 불리언 값으로 평가되어야 할 문맥에서 Truthy 값은 true로,
Falsy 값은 false로 암묵적 타입 변환됩니다.

Falsy 값

- false
- undefined
- null
- 0, -0
- NaN
- ""

이 외의 값은 Truthy 값입니다.

## 배열

### 자바스크립트의 배열은 자료구조의 배열과 같나요?

자료구조에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조를 말합니다. 이러한 배열은 밀집 배열이라고 합니다.

반면 JS에서 배열은 각 요소의 메모리 공간이 동일한 크기를 갖지 않아도 되고, 연속적이지 않아도 됩니다. 이를 희소 배열이라고 합니다.

즉, JS의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체입니다.

### 배열의 메서드는 어떤 종류가 있나요?

배열의 메서드를 크게 두 분류로 나눈다면 원본 배열을 변경하는가를 기준점으로 나눌 수 있을 것 같습니다.
ES5부터 도입된 배열 메서드는 대부분 원본 배열을 직접 변경하지 않지만, 초창기 배열 메서드는 원본 배열을 직접 변경하는 경우가 많습니다.

원본 배열을 직접 변경하는 메서드는 외부 상태를 변경하는 부수효과가 있으므로 사용할 때 주의해야 합니다.

### 고차 함수에 대해서 아나요?

고차 함수는 함수를 인수로 전달받거나 함수를 반환하는 함수를 말합니다.
JS의 함수는 일급 객체이므로 함수를 값처럼 인수로 전달할 수 있으며 반환할 수 있습니다.

고차 함수는 함수형 프로그래밍에 기반을 두고 있습니다.
함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하고 변수의 사용을 억제하여 프로그램의 안정성을 높이려는 프로그래밍 패러다임입니다.

### forEach 메서드와 map 메서드의 차이점에 대해 알고 있나요?

forEach 메서도와 map 메서드 모두 배열을 순회하며 콜백 함수를 호출하는 고차함수입니다.
하지만 forEach는 항상 undefined를 반환하고, map은 콜백 함수의 반환값들로 구성된 새로운 배열을 반환하는 차이점이 있습니다.

## 객체 리터럴

### 자바스크립트에서 객체란 뭘까요?

자바스크립트를 구성하는 거의 모든 것이 객체입니다.
원시 값을 제외한 나머지 값은 모두 객체이며, 키와 값으로 이루어진 자료구조입니다.

### 함수와 메서드의 차이점에 대해 알고 계신가요?

함수와 메서드의 차이점은 호출 방식에 있습니다.
함수를 호출하는 객체가 있는 경우 메서드라고 말하며, 없는 경우는 함수라고 말합니다.

### 자바스크립트에서 객체를 생성하는 방법은 어떤 것들이 있나요?

1. 객체 리터럴

```js
const person = {
  // ...
};
```

2. Object 생성자 함수

```js
const obj = new Object();
```

3. 생성자 함수

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.greet = function () {
    console.log("Hello, " + this.name);
  };
}

const alice = new Person("Alice", 30);
```

4. Object.create

```js
const personPrototype = {
  greet: function () {
    console.log("Hello, " + this.name);
  },
};

const alice = Object.create(personPrototype);
```

5. 클래스

```js
class Person {
  // ...
}
```

### 전역 객체에 대해서 아시나요?

전역 객체는 런타임 이전 단계에 어떤 객체보다도 먼저 생성되는 특수한 객체입니다.
브라우저에서는 window, Node.js에서는 global 객체를 의미합니다.
전역 객체는 표준 빌트인 객체와 환경에 따른 호스트 객체 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖습니다.

## 원시 값과 객체 비교

### 값에 의한 전달과 참조에 의한 전달에 대해 설명해주세요.

변수에 원시 값을 갖는 변수를 할당하면 할당 받는 변수에는 원시 값이 복사되어 전달됩니다. 이를 값에 의한 전달이라고 합니다.

반면 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달됩니다. 이를 참조에 의한 전달이라고 합니다.

결국 값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일합니다.
다만 식별자가 기억하는 메모리 공간의 값이 원시 값이냐 참조 값이냐의 차이만 있습니다.

## 함수

### 자바스크립트에서 함수를 정의하는 방법은 몇가지가 있나요?

1. 함수 선언문

```js
function add(x, y) {
  return x + y;
}
```

2. 함수 표현식

```js
const add = function (x, y) {
  return x + y;
};
```

3. 화살표 함수

```js
const add = (x, y) => x + y;
```

4. Function 생성자 함수

```js
const add = new Function("x", "y", "return x + y");
```

### 함수 선언문과 함수 표현식은 어떤 차이가 있나요?

함수 선언문은 값으로 평가되지 않는 표현식이 아닌 문이고,
함수 표현식은 값으로 평가되는 표현식인 문입니다.

함수 선언문으로 함수를 정의하면 런타임 이전에 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 동시에 함수 객체를 할당합니다.
함수 표현식의 경우 변수에 객체 값을 할당하는 과정이기 때문에 함수가 할당되기 이전에 호출할 수 없습니다.

### 즉시 실행 함수에 대해 알고 있나요?

함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라고 합니다.
그룹 연산자로 함수를 묶은 후 호출 연산자를 붙여 바로 호출합니다.

주로 변수의 유효 범위를 제한하거나 코드 충돌을 방지하기 위해 사용되며,
클래스 문법이 도입되기 이전에 모듈화를 구현할 때 자주 활용된 것으로 알고 있습니다.

## 스코프

### 스코프가 뭔가요?

스코프는 식별자가 유효한 범위를 말합니다.
모든 스코프는 하나의 계층적 구조로 연결되며, JS 엔진은 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색합니다.

### 스코프에는 어떤 종류가 있죠?

스코프는 크게 전역 스코프와 지역 스코프로 구분됩니다.
최상위 스코프인 전역 스코프는 코드 가장 바깥 영역을 말하며, 전역 변수는 어디서든 참조할 수 있습니다.
지역 스코프는 함수나 블록 내부의 스코프를 말합니다.
지역 변수는 자신의 스코프와 하위 지역 스코프에서 유효합니다.

### 렉시컬 스코프를 아나요? 안다면 렉시컬 스코프는 무엇을 의미하나요?

상위 스코프가 결정되는 방식에는 두 가지 패턴이 있습니다.

1. 함수를 어디서 호출했는지
2. 함수를 어디서 정의했는지

첫 번째 방식은 동적 스코프라고 하며, 함수의 상위 스코프가 호출 시점에 따라 계속해서 변할 수 있습니다.
두 번째 방식은 렉시컬 스코프라고 하며, 함수가 정의된 시점에 상위 스코프가 고정됩니다.

따라서, 렉시컬 스코프란 함수가 정의된 문맥에 따라 상위 스코프가 결정되는 것을 의미합니다.

### 전역 변수로 변수를 선언하면 생기는 문제점은 무엇이 있을까요?

모든 코드가 전역 변수를 참조하고 변경할 수 있다는 것은 전체 프로그램의 가독성이 나빠지고, 유지 보수하기 어렵게 만듭니다.
JS의 경우 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유하므로 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프에 존재할 경우 의도하지 않은 결과를 가져올 수 있습니다.

전역 변수는 생명 주기가 길어 메모리 리소스 또한 오래 소비합니다.

전역 변수는 스코프 체인 상 종점에 존재하기 때문에 검색 속도가 가장 느립니다.

## 생성자 함수에 의한 객체 생성

### 생성자 함수가 뭔가요?

생성자 함수란 new 연산자와 함께 호출하여 객체를 생성하는 함수를 말합니다.
생성자 함수에 의해 생성된 객체를 인스턴스라고 합니다.

### 객체 리터럴로 만들 때와 무슨 차이가 있죠? 왜 생성자 함수를 사용하나요?

객체 리터럴에 의한 생성 방식은 하나의 객체만 생성하기 때문에 같은 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 비효율적입니다.

생성자 함수를 정의하고 new 연산자를 호출하는 것으로 인스턴스를 만든다면 여러 개의 객체를 간편하게 생성할 수 있습니다.

### 생성자 함수가 객체를 생성하는 과정에 대해 간략하게 설명해줄 수 있나요?

new 연산자로 생성자 함수를 호출했을 때, 런타임 이전에 함수 내에서 암묵적으로 빈 객체가 생성되고 이 인스턴스에 this가 바인딩됩니다.
인스턴스 초기화 과정을 거치고, 함수 내 모든 처리가 끝나면 인스턴스가 바인딩 된 this가 암묵적으로 반환됩니다.

## 함수와 일급 객체

### 일급 객체가 뭔가요?

다음과 같은 조건을 만족하는 객체를 일급 객체라고 합니다.

1. 무명의 리터럴로 생성할 수 있다.
2. 변수나 자료구조에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환 값으로 사용할 수 있다.

### 일급 객체로 뭘 할 수 있나요?

함수를 매개변수로 사용하거나 반환값으로 사용함으로써 함수형 프로그래밍을 할 수 있습니다.

함수형 프로그래밍이란 순수 함수를 통해 부수 효과를 최대한 억제하여 프로그램의 안전성을 높이려는 프로그래밍 패러다임입니다.

_순수 함수: 외부 상태에 의존하지도 변경하지도 않는 부수 효과가 없는 함수_

## Map과 Set

### Map

Map은 자료를 저장하는데에 있어서 단순한 객체의 확장 버전입니다.

1. 문자열과 심벌만 허용되는 객체와 달리 모든 타입의 키를 사용 가능합니다.
2. Map은 삽입 순서를 기억합니다.
3. 성능 최적화: 키-값 쌍을 추가, 삭제, 검색하는 작업에서 성능이 더 뛰어날 수 있습니다.
4. 키의 고유성 보장: 덮어쓰기가 발생하지 않습니다.

### Set

Set 객체는 중복되지 않는 유일한 값들의 집합으로 수학적 집합을 구현하기 위한 자료구조입니다.

## 프로토타입

### 객체지향 프로그래밍은 무엇을 의미하나요?

객체지향 프로그래밍은 객체라는 단위를 중심으로 프로그램을 설계하고 구현하는 방식입니다. 객체는 상태(프로퍼티)와 행동(메서드)를 포함하며 아래와 같은 특징이 있습니다.

**객체지향 프로그래밍의 특징**

1. 추상화
2. 캡슐화
3. 상속
4. 다형성

### 자바스크립트는 객체지향 프로그래밍 언어인가요?

JS는 객체지향 프로그래밍 뿐만 아니라 명령형, 함수형 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어입니다.
이때 클래스 기반 객체지향 프로그래밍 언어가 아닌 프로토타입 기반의 객체지향 프로그래밍입니다.

### 프로토타입이 뭔가요?

프로토타입은 객체의 부모 객체로서, 다른 객체에 공유 프로퍼티와 메서드를 제공합니다.

모든 객체는 프로토타입을 가지고 있으며, 자바스크립트는 이를 기반으로 객체지향 프로그래밍을 구현하고 불필요한 중복을 제거합니다.

## Strict Mode

### strict mode가 뭔가요?

stict mode는 JS 언어의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나 JS 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킵니다.

`use strict;`를 통해 적용시킬 수 있습니다.

### strict mode를 통해 무엇을 예방할 수 있죠?

1. 암묵적 전역
2. 변수, 함수, 매개변수의 삭제
3. 매개변수 이름의 중복

## 빌트인 객체

### 빌트인 객체가 뭔가요?

개발자가 모든 기능을 구현하지 않고, 편하게 개발할 수 있도록 JS에서 기본적으로 제공하는 객체입니다.

### 빌트인 객체의 종류는 어떤게 있죠?

빌트인 객체는 크게 생성자 함수 객체와 그 외 객체로 구분할 수 있습니다.

Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 생성자 함수입니다. 이 객체들은 정적 메서드만 제공합니다.

### 래퍼 객체에 대해서 알고 있나요?

래퍼 객체는 원시 타입을 마치 객체 타입처럼 사용하는 과정 속에서 생기는 임시 객체입니다. (String, Number, Boolean)

객체처럼 마침표 표기법으로 접근하면 JS 엔진이 일시적으로 원시값을 연관된 객체로 변환해줍니다.

이후 특정 작업을하고 다시 원시값으로 되돌립니다.

## this

### this가 뭔가요?

this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수입니다.

단, this가 가리키는 값은 함수 호출 방식에 의해 동적으로 결정됩니다.

### this 바인딩이란?

바인딩은 변수와 값을 연결하는 과정을 의미합니다.
this 바인딩은 this가 가리킬 객체를 바인딩하는 것입니다.
이때 this 바인딩은 함수 호출 방식에 의해 동적으로 결정됩니다.

### this는 동적으로 바인딩이 된다고 하는데 바인딩되는 객체가 어떻게 다르나요?

- 일반 함수: 전역 객체
- 메서드: 메서드를 호출한 객체
- 생성자 함수: 생성자 함수가 생성할 인스턴스

## 실행 컨텍스트

### 실행 컨텍스트에 대해 말해보세요

실행 컨텍스트는 코드를 실행하는 데 필요한 환경을 제공하는 객체입니다.
코드가 실행되기 위해서는 식별자, 스코프, 코드의 실행 순서 등을 관리해야 하며, 이러한 요소들을 실행 컨텍스트가 관리합니다.

식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리됩니다.
렉시컬 환경은 환경 레코드와 외부 렉시컬 환경에 대한 참조로 구성됩니다.
환경 레코드는 스코프에 포함된 식별자를 등록하고, 바인딩 된 값을 관리하는 저장소입니다.
외부 렉시컬 환경에 대한 참조는 상위 스코프의 렉시컬 환경을 참조하여 스코프 체인을 형성합니다.

그리고 코드의 실행 순서는 실행 컨텍스트 스택으로 관리됩니다.
실행 컨택스트 스택은 후입선출 방식의 자료구조이며, 콜스택이라고 부르기도 합니다.
함수가 호출되면 실행 컨텍스트가 스택에 추가되고, 실행이 완료되면 제거됩니다.

## 클로저

### 클로저에 대해 아나요?

클로저는 자신이 선언될 당시의 환경을 기억하는 함수로,
주로 중첩된 함수로 구현됩니다.

외부 함수의 실행이 종료되고 콜 스택에서 제거된 후에도 내부 함수가 외부 함수의 변수를 계속해서 참조하는 경우를 의미합니다.

### 클로저를 사용하면 뭐가 좋죠?

클로저는 상태를 안전하게 변경하고 유지하기 위해 사용합니다.
상태를 은닉하고 특정 함수에게만 상태 변경을 허용할 수 있습니다.
